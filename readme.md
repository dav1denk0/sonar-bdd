## Sonar BDD Project

Sonar BDD is a project with testing purpose over the Sonar Service Project. Sonar is a service to store and normalize information about places from different providers.

In this case, we're using Behat to test the Sonar features in a Behavior Driven Development way. Also, frameworks like Laravel, Composer and Guzzle are also used in this project.
This project was developed in a trial version of PhpStorm 8 IDE under Windows OS. And the PHP language version is the following:

    PHP 5.5.25 (cli) (built: May 13 2015 19:58:58)
    Copyright (c) 1997-2015 The PHP Group
    Zend Engine v2.5.0, Copyright (c) 1998-2015 Zend Technologies

### Project Setup

First of all open a command window and go to the project root folder. We need to install Composer by running in a command window:

    curl -s http://getcomposer.org/installer | php

Then, we already had a composer.json file in our project root with all the dependencies that we need to get the Sonar BDD project working.
To install all dependencies (behat, laravel, guzzle, etc.) we need to execute the following command:

    php composer.phar install
    
If any change was made in composer.json file we need to 'update' composer to take changes and to download new dependencies.

    composer update
    
Please, if you have any problems with the previous command and your dependencies are not in /vendor folder, try to execute the previous composer update command

### Frameworks and Dependencies

The following frameworks and dependencies were used with Composer:

    - Laravel for PHP
    - Behat for BDD features design
    - PHPUnit Assertion functions for Steps
    - Guzzle for REST requests
    
I'd like to use Hamcrest matchers instead of PHPUnit assertion functions, but it was messy to setup and use. It's almost the same for the project's purpose but Hamcrest is more complex and complete number of assertion matchers.

### Executing the scenarios

To execute Behat scenarios you need to:
- Open a command window
- Go to the project root folder
- Execute the following sentence:
	
	bin/behat --tags "@tagname"
	
Where "@tagname" is a specific tag that describes the scenario or the group of tests that you want to execute.
The current scenarios have been tagged with labels that groups them in a logical sequence. The following tags are available:

	@regression : Runs all features for a complete regression test execution
	@sanity : Runs all basic scenarios to make sure that the main functionalities of the application are working as expected
	@facebook_e2e : Runs an end to end test using Facebook provider. It's like a sanity test for Facebook
	@foursquare_e2e : Runs an end to end test using Foursquare provider. It's like a sanity test for Foursquare
	
Also, every scenario has a unique tag name that can be invoked to execute that single test only.

### Execution Reports

A few execution reports in HTML and XML format were stored in the project root folder under "reports" folder. Here's the GitHub link to the reports folder:

	[Reports in GitHub](https://github.com/dav1denk0/sonar-bdd/tree/master/reports)

The reports were generated by Behat framework in a execution that was made this way:

	bin/behat -f html --out {filePath}/report.html --tags "@tagname" ---> for HTML reports
	
	bin/behat -f junit --out {filePath}/report_folder --tags "@tagname" ---> for JUNIT reports in XML
	
### A few comments about this project

There was a number of design concerns that I would like to implement with more time and knowledge in PHP language.
I'm new in this language, so i'm dealing with it's syntax and the frameworks, but I would like to have made a better design tests with this improvements:

 - Scenarios with wrong ID for Providers and Sonar UUID. Those scenarios were not made due the following specification in the exercise:
   "Do not attempt to find ids by yourself on Facebook or Foursquare API as you may interfere with the work of other interviewees". 
   Usually, alternative and negative scenarios use wrong id's to attempt to get a resource but I was not able to do that for the risk to get an actual ID. 
 - Scenarios with example tables and scenarios outlines for multiple tests with the same purpose to different providers
 - A common steps and method classes to have a better implementation and less repeated code
 - JSON response files for each test with format expected to check the whole response from a REST request instead of a few attributes
 - A response template with all the response codes and a common message for all the requests in the tests
 - A complete documentation for RequestContext.php functions explaining the purpose of each one
 - A CI tool like Jenkins or Bamboo implemented to manage test executions, regression and sanity jobs with it's results 
 
 